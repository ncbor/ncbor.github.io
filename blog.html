---
layout: default
title: "Blog"
---

<!-- blog/index.html -->
<!doctype html>
<html lang="pt-BR">
    <head>
        <meta charset="UTF-8" />
        <title>Blog</title>
        <!-- Inclua aqui o script de rastreamento ativado -->
    </head>
    <body>
        <nav><!-- mesmo nav --></nav>
        <h1>Blog</h1>
        <!-- <ul class="posts-list">
            {% for post in site.posts %}
            <li class="card">
                <a href="{{ post.url }}">{{ post.title }}</a>
                –
                <time datetime="{{ post.date | date_to_xmlschema }}">
                    {{ post.date | date: "%Y-%m-%d" }}
                </time>
                <p>{{ post.excerpt | strip_html | truncate: 120 }}</p>
            </li>
            {% endfor %}
        </ul> -->
        <h2>Jornada KERNEL</h2>
        <h3>Semana 1</h3>
        <p>
            Na primeira semana, começamos a preparar o ambiente para buildar o
            kernel através do tutorial
            <a href="https://flusp.ime.usp.br/kernel/qemu-libvirt-setup/"
                >Setting up a test environment for Linux Kernel Dev using QEMU
                and libvirt</a
            >
            do grupo FLUSP. O Gabriel, minha dupla, não conseguiu fazer no MacOS dele, então
            fizemos ambos no meu notebook, rodando Arch Linux. Foi tranquilo de instalar a imagem apropriada, e o tutorial acabava aí.
        </p>
        <h3>Semana 2</h3>
        <p>
            Na segunda semana, o tutorial foi:
            <a href="https://flusp.ime.usp.br/kernel/build-linux-for-arm/"
                >Building and booting a custom Linux kernel for ARM</a
            >.  Foi designado a nós o uso de kw durante as atividades. Amaioria dos passos deu certo,
            <b
                >menos quando deixei o meu ssh aberto por 20 minutos com acesso
                root sem senha para qualquer um que quisesse kkkkkkk</b
            >. Ainda bem que o Davi logo interviu e reverteu isso. Dale IMEsec.
            Além disso, senti um pouco de dificuldade de internalizar o uso de
            VMs, que veio naturalmente conforme as outras aulas aconteceram.
        </p>
        <h3>Semana 3</h3>
        <p>
            Essa foi a semana de problemas na eduroam, e tivemos que rodar
            nossa conexão via 3g. No final das contas, após muito esperar as
            etapas concluirem via internet móvel, não funcionou porque eu
            deletei a bridge que conectava a VM ao ssh (ou algo assim). Ainda bem, salvou meus pacotes kkkkk. Fomos
            para casa e só conseguimos resolver o problema do bridge deletado e completar o
            tutorial 1 e 2 plenamente ao abrir uma máquina na CONTABO. Nós usamos ela até hoje, resolvendo o problema do MacOS da
            minha dupla e permitindo que nós dois usássemos a mesma máquina para o desenvolvimento. E, sem maiores delongas, conseguimos cumprir os
            objetivos do tutorial<a
                href="https://flusp.ime.usp.br/kernel/modules-intro/"
                >Introduction to Linux kernel build configuration and modules</a
            >
            sem outras grandes dificuldades.
        </p>
        <h3>Semana 4</h3>
        <p>
            Essa foi a primeira semana que conseguimos usar a VPS da CONTABO
            plenamente durante o encontro. Realizamos então o tutorial 4 <a href="https://flusp.ime.usp.br/kernel/char-drivers-intro/"
                >Introduction to Linux kernel Character Device Drivers</a
            > sem nenhuma grande dificuldade, ainda mais com a GUI envolvida. Até aqui, o kw se mostrou uma mão na roda para simplificar os processos.
            O que mais atrapalhou, no fim das contas, foi a demora da máquina da CONTABO para alguns procedimentos, principalmente buildar.
        </p>
        <h3>Semana 5</h3>
        <p>
            Eu e Gabriel não fomos nesse encontro, e nos comprometemos a
            concluir o tutorial 5, (<a
                href="https://flusp.ime.usp.br/iio/iio-dummy-anatomy/"
                >The iio_simple_dummy Anatomy</a
            >), em casa. Por sorte nossa, esse tutorial não tinha nada pra fazer na prática,
            apenas ler e entender a organização do IIO subsystem. Concluimos a etapa 5 sem grandes problemas,
            e agora estávamos prontos para começar nosso patch.

        <h3>Semana 6 + break</h3>
            Nessa semana, especificamente no dia do encontro, passei mal durante
            a parte da manhã e não pude estar presencialmente na aula. Assim, o
            Gabriel pegou todas informações para que conseguissemos fazer o patch juntos durante o Break. E
            assim foi feito, mesmo eu tendo que alcançar o andamento do Gabriel em algumas partes.
        </p>
        <p>
            O Gabriel decidiu então que nós trataríamos de
            duplicações de código, e como eu não fui na aula, aceitei a decisão. Então, focamos em melhorar o código do
            arquivo `adc/sc27xx_adc.c`. O trabalho consistiu em generalizar
            algumas funções internas, além de melhorar drásticamente (na minha
            opinião) a legibilidade do script, removendo alguns switches
            <s>feios</s> que atrapalhavam. Nosso resultado consisstiu na nova
            função `sc27xx_adc_scale_init` e na nova estrutura
            `adc_channel_scale` (para guardar os dados dos PMIC). Assim,
            acreditamos que alcançamos nossos objetivos estipulados para com
            este arquivo.
        </p>
        <p>
            Nós dois geramos o patch juntos por discord, e o Gabriel ficou responsável por enviar pro Davi, sem maiores dificuldades. Para mais informações, acesse o
            <a href="https://www.linux.ime.usp.br/~apolo/mac0470/"
                >site do Gabriel</a
            >
        </p>
        <h3>Semana 7: PITCH!</h3>
        <p></p>

        <h3><a href="https://lore.kernel.org/linux-iio/20250428034222.318898-1-gabrielgeraldinosouza@gmail.com/T/#u">Fim do Kernel :)</a></h3>

        <h2>Parte 2: KW</h2>

        <p>No começo, cogitamos mexer com pacotes como Pacman, ou Git, mais presentes no nosso dia a dia. Porém, após comparar as issues abertas e o fluxo de contribuição, preferimos seguir com o <code>kw</code> em vez das outras possibilidades.</p>
        <p>A princípio, iriamos mexer com a issue <a href="https://github.com/kworkflow/kworkflow/issues/1207">#1207</a>, que trata sobre a lista de email para edições em mais de um subsystem do kernel. Porém, após falar com o Davi, percebemos que poderia ser uma escolha do kw fazer as coisas do jeito que a issue reclama. Então, decidimos mexer na issue <a href="https://github.com/kworkflow/kworkflow/issues/1185">#1185</a>, cujo problema consiste em envs diferentes com o mesmo nome em worktrees diferentes compartilham configurações e sobrescrevem arquivos compilados.</p>
    <pre><code>
    Description:

    If an user creates two environments with the same name, but in different repositories and therefore, different config files, compiled files and kw settings, the latest environment used replaces everything from the previous one.

    How to Reproduce:

    Clone two different kernel repositories
    Create a kw env with the same name, for example, LOCAL
    Setup and compile file in repository 1 under LOCAL env.
    In another tab, use the LOCAL env in repository 2. it will use everything from LOCAL env in repository 1.

    </code></pre>

    <h3>Solução</h3>
    <p>Nossa ideia consiste em usar base64 do pwd para contornar esse problema. Primeiramente, pensamos em adicionar um sufixo ao nome do env, e os próximos passos podem ser vistos abaixo. Vale notar que a partir daqui, a maior parte do desenvolvimento foi feita juntamente por <b></b>discord</b></p>
        
    <h3>Primeiro Pull Request</h3>
    <p>Nosso primeiro PR consistiu na implementação dessa ideia, com sete commits. Porém, antes de tudo, o rodrigosiqueira respondeu para organizarmos os commits de forma mais enxuta, direta ao ponto. Além disso, pediu para que não usassemos sufixos, mas sim um diretório único e exclusivo com o <code>base64(pwd)</code>. Também foi notado que estávamos alterando o contexto local, sendo que o problema só ocorria no contexto global. Finalmente, foram pedidos testes no mesmo commit das novas funções, e reforçou para que seguissemos o guideline de codestyle do kw.</p>

    <h3>Segundo Pull Request</h3>
    <p>No segundo push adotou-se então o novo formato de codificação, reorganização de commits, adição de testes, e aplicação do codestyle. A solução apresentada aqui foi a solução final enviada por nós:</p>
        <pre><code>${cache_build_path}/${ENV_DIR}/${encoded_pwd}/${current_env_name}</code></pre>
    <p>O siqueira novamente respondeu com algumas recomendações de edição, sendo a principal delas a adição de uma função que migrará os ambientes dos usuários de kw para o novo formato, nomeada por ele como <code>migrate_old_env_to_base64</code>. Basicamente, ela verifica estrutura de diretórios no cache e invocá-la logo no início de main em kw_env.sh</p>

    <h3>Terceiro Pull Request</h3>
    <p>A migração foi implementada, acompanhada de novos testes e correção de bugs. Os commits relevantes foram registrados conforme abaixo:</p>
    <pre><code>
999ed24 Introduz função para codificar $PWD
79d1b07 Ajusta funções para usar PWD codificado como cache_build_path
4f517ce Migra ambientes existentes para novo caminho
    </code></pre>
    <p>O comando de listagem de ambientes agora detecta diretório antigo, aplica migração automática antes de listar e remove operações destrutivas diretas, garantindo compatibilidade retroativa.</p>
    <p>Estamos no aguardo da resposta dele, dispostos a contribuir com o que mais for necessário. Aliás, pessoalmente estive interessado em realizar outras contribuições após mexer com o kw, cuja experiência foi mais leve e engajante do que contribuir com o kernel, e mais aprofundada do que a contribuição debian abaixo. Também vale notar que o Gabriel está com uma ideia nova e vai criar uma nova issue no repositório do kworkflow.</p>
    <p>Para imagens, entre no <a href="https://www.linux.ime.usp.br/~apolo/mac0470/">no site do Gabriel</a>, pois não consegui adicionar aqui :).</p>





        <h2>Parte 3: Jornada Debian</h2>
        <p>Nas duas últimas aulas da disciplina antes dos pitches finais, nosso professor Paulo apresentou Charles e Lucas Kanashiro, mantenedores do Debian Brasil. A experiência de conhecer esses contribuintes experientes e entender seu papel no projeto foi bem interessante, além de serem bastante carismáticos e explicativos.</p>
        <p>Após as palestras, ficamos encarregados de atualizar alguns pacotes do ecossistema Debian. Meu pacote foi o <code>dhcpig</code>, que integra o componente main, subsystem net, fornecendo um utilitário de auditoria de rede para simular ataques de esgotamento de alocação DHCP.</p>
        <p>Na parte de empacotamento, editamos o arquivo <code>debian/control</code> para atualizar a versão, commitamos, e em seguida geramos outro commit contendo o changelog do anterior (presente em <code>debian/changelog</code>). Se engana quem acha que é simples assim: Charles e Lucas deixaram tudo na boca do gol para nós, arrumando todos os outros trechos de código necessários antes da aula.</p> 
        <p>Poucos dias depois, Charles aprovou o merge request, validando nosso entendimento básico do fluxo de contribuições do Debian.</p>
        <p>Assim, com um projeto leve e engajante, terminamos a disciplina de Software Livre e nos preparamos para o pitch final.</p>

        <h3>Pitch Final!! (pov)</h3>




        <h3>.</h3>
        <h3>.</h3>
        <h3>.</h3>
        <h2>CAMINHOS</h2>
        <p>Pretendo seguir a trilha da Pós. Como não tem ainda no <a href="https://bcc.ime.usp.br/trilhas/">site oficial do BCC</a>, também manifesto aqui meu interesse em seguir a trilha de Teoria da Computação.</p>



    </body>
</html>
